# 그래프란 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조이다.
# "알고리즘 문제를 접했을 때 서로 다른 개체가 연결되어 있다."는  이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올려야 한다.
# "여러 개의 도시가 연결되어 있다"는 내용이 등장하면 그래프 알고리즘을 의심해보자
# 더불어 그래프 자료구조 중 트리 자료구조는 다양한 알고리즘에 사용한다.

# 다익스트라 최단 경로 알고리즘은 우선순위 큐가 사용되었다.
# 우선순위 큐를 구현하기 위해 최소 힙이나 최대 힙을 이용할 수 있다.

#                                  그래프                               트리
# 방향성                 방향 그래프 혹은 무방향 그래프               방향 그래프
# 순환성                       순환 및 비순환                           비순환
# 루트 노드 존재 여부          루트 노드가 없음                     루트 노드가 존재
# 노드간 관계성              부모와 자식 관계 없음                  부모와 자식 관계
# 모델의 종류                    네트워크 모델                         계층 모델

# 그래프의 구현 방법은 두가지로 나뉜다.
# 1. 인접 행렬(Adjacency Matrix) : 2차원 배열을 사용하는 방식
# 2. 인접 리스트(Adjacency List) : 리스트를 사용하는 방식

# 인접 행렬은 공간복잡도이 높지만, 시간복잡도는 낮다.
# 인접 리스트는 공간복잡도는 낮지만, 시간복잡도는 높다.

# 플로이드 워셜 알고리즘은 인접 행렬을 사용하는 방식이다.
# 반면 다익스트라 알고리즘은 인접 리스트를 사용한다.
# 때문에 최단 경로 문제가 출제되었을 경우 노드의 개수가 적은 경우에는 플로이드 워셜 알고리즘을
# 노드와 간선의 개수가 많은 경우 우선순위 큐를 이용하는 다익스트라 알고리즘을 이용하면 유리하다.

# 서로소 집합 : 공통 원소가 없는 두 집합. => 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
# union과 find 연산으로 조작할 수 있다.
# union : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산.
# find : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다.
# 따라서 서로소 집합 자료구조는 union-find 자료구조로 불리기도 하다.

#서로소 집합 알고리즘 소스코드

# def find_parent(parent, x):
#     if parent[x] != x:
#         parent[x] = find_parent(parent, parent[x])
#     return parent[x]

# def union_parent(parent, a, b):
#     a = find_parent(parent, a)
#     b = find_parent(parent, b)
#     if a < b:
#         parent[b] = a
#     else:
#         parent[a] = b

# v = 6
# e = 4
# parent = [0] * (v + 1)

# for i in range(1, v + 1):
#     parent[i] = i

# graph = [[1, 4], [2, 3], [2, 4], [5, 6]]

# for i in graph:
#     union_parent(parent, i[0], i[1])

# print(parent[1:])

# 신장 트리(Spanning Tree)
# 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
# 조건 : 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건이 성립해야한다.

# 크루스칼 알고리즘
# 최소 비용으로 신장 트리를 찾는 알고리즘
# ex) N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 전체 도시가 서로 연결될 수 있게 도로를 설치하는 경우
# 이같은 경우를 최소 신장 알고리즘이라 부르고, 대표적으로 크루스칼 알고리즘이 이에 속한다.

# 크로스칼 알고리즘은 그리디 알고리즘으로 분류된다.
# 먼저 모든 간선에 대하여 정렬을 수행한 뒤에 가장 거리가 짧은 간선부터 집합에 포함시키면 된다.

# 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
# 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
#  - 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
#  - 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
# 모든 간선에 대하여 2번 과정을 반복한다.

# 특정 원소가 속한 집합 찾기.
# def find_parent(parent, x):
#     # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
#     if parent[x] != x:
#         parent[x] = find_parent(parent, parent[x])
#     return parent[x]

# def union_parent(parent, a, b):
#     a = find_parent(parent, a)
#     b = find_parent(parent, b)
#     if a < b:
#         parent[b] = a
#     else:
#         parent[a] = b

# v = 7
# e = 9

# edges = [[1, 2, 29], [1, 5, 75], [2, 3, 35], [2, 6, 34], [3, 4, 7], [4, 6, 23],
#          [5, 6, 53], [6, 7, 25]]

# result = 0
# parent = [0] * (v + 1)

# for i in range(1, v + 1):
#     parent[i] = i

# edges.sort()

# for edge in edges:
#     a, b, cost = edge
#     if find_parent(parent, a) != find_parent(parent, b):
#         union_parent(parent, a, b)
#         print(cost)
#         result += cost

# print(result)

# 위상 정렬(Topology Sort)
# 위상 정렬은 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘이다.
# 위상 정렬이란 방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'이다.

# 위상 정렬 알고리즘은 진입차수(Indegree)를 알아야한다.
# 진입차수란 특정한 노드로 들어오는 간선의 개수를 의미한다.

# 진입차수가 0인 노드를 큐에 넣는다.
# 큐가 빌 때까지 다음의 과정을 반복한다.
#    - 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
#    - 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

# 이 알고리즘을 이용하여 간단하게 위상 정렬을 수행할 수 있다.
# 방향성을 가진 그래프의 순서를 측정할 때는 위상정렬을 쓴다.

from collections import deque

v = 7
e = 8
m = [[1, 2], [1, 5], [2, 3], [2, 6], [3, 4], [4, 7], [5, 6], [6, 4]]

